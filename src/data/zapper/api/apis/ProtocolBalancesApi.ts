/* tslint:disable */
/* eslint-disable */
/**
 * Zapper API
 * The Zapper API provides some of the most robust Defi related data, everything from liquidity and prices on different AMMs to complex Defi protocol balances all in one convenient place. In addition, the API also supports bridging between different networks as well as formatted Zap transaction endpoints. <br/><br/><br/> *Enter in our public API key in the Authorize section below to test the endpoints directly in swagger: **96e0cc51-a62e-42ca-acee-910ea7d2a241**
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ProtocolBalanceResponse,
    ProtocolBalanceResponseFromJSON,
    ProtocolBalanceResponseToJSON,
} from '../models';

export interface BalanceControllerGetProtocolBalancesV2Request {
    protocol: BalanceControllerGetProtocolBalancesV2ProtocolEnum;
    addresses: Array<string>;
    network?: BalanceControllerGetProtocolBalancesV2NetworkEnum;
}

export interface BalanceControllerGetSupportedV2BalancesRequest {
    addresses: Array<string>;
}

export interface StakingControllerGetStakedBalancesRequest {
    stakedBalanceType: StakingControllerGetStakedBalancesStakedBalanceTypeEnum;
    addresses: Array<string>;
    network?: StakingControllerGetStakedBalancesNetworkEnum;
}

/**
 * 
 */
export class ProtocolBalancesApi extends runtime.BaseAPI {

    /**
     * Gets balances of different supported protocols
     * Protocol Balances
     */
    async balanceControllerGetProtocolBalancesV2Raw(requestParameters: BalanceControllerGetProtocolBalancesV2Request): Promise<runtime.ApiResponse<ProtocolBalanceResponse>> {
        if (requestParameters.protocol === null || requestParameters.protocol === undefined) {
            throw new runtime.RequiredError('protocol','Required parameter requestParameters.protocol was null or undefined when calling balanceControllerGetProtocolBalancesV2.');
        }

        if (requestParameters.addresses === null || requestParameters.addresses === undefined) {
            throw new runtime.RequiredError('addresses','Required parameter requestParameters.addresses was null or undefined when calling balanceControllerGetProtocolBalancesV2.');
        }

        const queryParameters: any = {};

        if (requestParameters.addresses) {
            queryParameters['addresses[]'] = requestParameters.addresses;
        }

        if (requestParameters.network !== undefined) {
            queryParameters['network'] = requestParameters.network;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/protocols/{protocol}/balances`.replace(`{${"protocol"}}`, encodeURIComponent(String(requestParameters.protocol))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProtocolBalanceResponseFromJSON(jsonValue));
    }

    /**
     * Gets balances of different supported protocols
     * Protocol Balances
     */
    async balanceControllerGetProtocolBalancesV2(requestParameters: BalanceControllerGetProtocolBalancesV2Request): Promise<ProtocolBalanceResponse> {
        const response = await this.balanceControllerGetProtocolBalancesV2Raw(requestParameters);
        return await response.value();
    }

    /**
     * Gets the protocols supported for each supported network
     * Supported Protocols
     */
    async balanceControllerGetSupportedV2BalancesRaw(requestParameters: BalanceControllerGetSupportedV2BalancesRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.addresses === null || requestParameters.addresses === undefined) {
            throw new runtime.RequiredError('addresses','Required parameter requestParameters.addresses was null or undefined when calling balanceControllerGetSupportedV2Balances.');
        }

        const queryParameters: any = {};

        if (requestParameters.addresses) {
            queryParameters['addresses[]'] = requestParameters.addresses;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/protocols/balances/supported`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Gets the protocols supported for each supported network
     * Supported Protocols
     */
    async balanceControllerGetSupportedV2Balances(requestParameters: BalanceControllerGetSupportedV2BalancesRequest): Promise<void> {
        await this.balanceControllerGetSupportedV2BalancesRaw(requestParameters);
    }

    /**
     * Retrieves staked balances for a given type
     * Staked Balances
     */
    async stakingControllerGetStakedBalancesRaw(requestParameters: StakingControllerGetStakedBalancesRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.stakedBalanceType === null || requestParameters.stakedBalanceType === undefined) {
            throw new runtime.RequiredError('stakedBalanceType','Required parameter requestParameters.stakedBalanceType was null or undefined when calling stakingControllerGetStakedBalances.');
        }

        if (requestParameters.addresses === null || requestParameters.addresses === undefined) {
            throw new runtime.RequiredError('addresses','Required parameter requestParameters.addresses was null or undefined when calling stakingControllerGetStakedBalances.');
        }

        const queryParameters: any = {};

        if (requestParameters.addresses) {
            queryParameters['addresses[]'] = requestParameters.addresses;
        }

        if (requestParameters.network !== undefined) {
            queryParameters['network'] = requestParameters.network;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/staked-balance/{stakedBalanceType}`.replace(`{${"stakedBalanceType"}}`, encodeURIComponent(String(requestParameters.stakedBalanceType))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves staked balances for a given type
     * Staked Balances
     */
    async stakingControllerGetStakedBalances(requestParameters: StakingControllerGetStakedBalancesRequest): Promise<void> {
        await this.stakingControllerGetStakedBalancesRaw(requestParameters);
    }

}

/**
    * @export
    * @enum {string}
    */
export enum BalanceControllerGetProtocolBalancesV2ProtocolEnum {
    Autofarm = 'autofarm',
    Aave = 'aave',
    AaveAmm = 'aave-amm',
    AaveV2 = 'aave-v2',
    Alchemix = 'alchemix',
    Alpha = 'alpha',
    BProtocol = 'b-protocol',
    Badger = 'badger',
    Balancer = 'balancer',
    Bancor = 'bancor',
    Barnbridge = 'barnbridge',
    Bitcoin = 'bitcoin',
    Compound = 'compound',
    Cover = 'cover',
    Cream = 'cream',
    Curve = 'curve',
    Defisaver = 'defisaver',
    Derivadex = 'derivadex',
    Dhedge = 'dhedge',
    Dforce = 'dforce',
    Dodo = 'dodo',
    Dsd = 'dsd',
    Dydx = 'dydx',
    Ellipsis = 'ellipsis',
    Esd = 'esd',
    Futureswap = 'futureswap',
    Idle = 'idle',
    Harvest = 'harvest',
    Hegic = 'hegic',
    KeeperDao = 'keeper-dao',
    Linkswap = 'linkswap',
    Loopring = 'loopring',
    Liquity = 'liquity',
    Maker = 'maker',
    Mooniswap = 'mooniswap',
    Mushroom = 'mushroom',
    _1inch = '1inch',
    Pancakeswap = 'pancakeswap',
    Nft = 'nft',
    Other = 'other',
    Pickle = 'pickle',
    Pooltogether = 'pooltogether',
    Quickswap = 'quickswap',
    Rari = 'rari',
    Realt = 'realt',
    Reflexer = 'reflexer',
    Saddle = 'saddle',
    Sfinance = 'sfinance',
    Shell = 'shell',
    Smoothy = 'smoothy',
    Snowswap = 'snowswap',
    Sushiswap = 'sushiswap',
    Swerve = 'swerve',
    Synthetix = 'synthetix',
    Tokensets = 'tokensets',
    Tokens = 'tokens',
    Uniswap = 'uniswap',
    UniswapV2 = 'uniswap-v2',
    Unit = 'unit',
    Value = 'value',
    Venus = 'venus',
    Vesper = 'vesper',
    Xsigma = 'xsigma',
    Yearn = 'yearn'
}
/**
    * @export
    * @enum {string}
    */
export enum BalanceControllerGetProtocolBalancesV2NetworkEnum {
    Ethereum = 'ethereum',
    Polygon = 'polygon',
    Optimism = 'optimism',
    Xdai = 'xdai',
    BinanceSmartChain = 'binance-smart-chain',
    Fantom = 'fantom'
}
/**
    * @export
    * @enum {string}
    */
export enum StakingControllerGetStakedBalancesStakedBalanceTypeEnum {
    Masterchef = 'masterchef',
    Geyser = 'geyser',
    Gauge = 'gauge',
    SingleStaking = 'single-staking'
}
/**
    * @export
    * @enum {string}
    */
export enum StakingControllerGetStakedBalancesNetworkEnum {
    Ethereum = 'ethereum',
    Polygon = 'polygon',
    Optimism = 'optimism',
    Xdai = 'xdai',
    BinanceSmartChain = 'binance-smart-chain',
    Fantom = 'fantom'
}
