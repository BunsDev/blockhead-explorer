/* tslint:disable */
/* eslint-disable */
/**
 * Zapper API
 * The Zapper API provides some of the most robust Defi related data, everything from liquidity and prices on different AMMs to complex Defi protocol balances all in one convenient place. In addition, the API also supports bridging between different networks as well as formatted Zap transaction endpoints. <br/><br/><br/> *Enter in our public API key in the Authorize section below to test the endpoints directly in swagger: **96e0cc51-a62e-42ca-acee-910ea7d2a241**
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';

export interface ApprovalControllerGetApprovalStateRequest {
    tokenAddress: string;
    spenderAddress: string;
    ownerAddress: string;
    amount?: string;
    network?: ApprovalControllerGetApprovalStateNetworkEnum;
}

export interface ApprovalControllerGetApprovalTransactionRequest {
    tokenAddress: string;
    spenderAddress: string;
    ownerAddress: string;
    gasPrice: string;
    amount?: string;
}

export interface ExchangeControllerGetExchangePriceRequest {
    sellTokenAddress: string;
    buyTokenAddress: string;
    sellAmount: string;
    gasPrice: string;
    ownerAddress?: string;
    slippagePercentage?: number;
    network?: ExchangeControllerGetExchangePriceNetworkEnum;
}

export interface ExchangeControllerGetExchangeQuoteRequest {
    sellTokenAddress: string;
    buyTokenAddress: string;
    sellAmount: string;
    gasPrice: string;
    ownerAddress?: string;
    slippagePercentage?: number;
    network?: ExchangeControllerGetExchangeQuoteNetworkEnum;
}

/**
 * 
 */
export class ExchangeApi extends runtime.BaseAPI {

    /**
     * Returns data about if a token has been approved. **spenderAddress** for exchanging is the **allowanceTarget** value is returnded from the Exchange Price endpoint.
     * Token Approval State
     */
    async approvalControllerGetApprovalStateRaw(requestParameters: ApprovalControllerGetApprovalStateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.tokenAddress === null || requestParameters.tokenAddress === undefined) {
            throw new runtime.RequiredError('tokenAddress','Required parameter requestParameters.tokenAddress was null or undefined when calling approvalControllerGetApprovalState.');
        }

        if (requestParameters.spenderAddress === null || requestParameters.spenderAddress === undefined) {
            throw new runtime.RequiredError('spenderAddress','Required parameter requestParameters.spenderAddress was null or undefined when calling approvalControllerGetApprovalState.');
        }

        if (requestParameters.ownerAddress === null || requestParameters.ownerAddress === undefined) {
            throw new runtime.RequiredError('ownerAddress','Required parameter requestParameters.ownerAddress was null or undefined when calling approvalControllerGetApprovalState.');
        }

        const queryParameters: any = {};

        if (requestParameters.tokenAddress !== undefined) {
            queryParameters['tokenAddress'] = requestParameters.tokenAddress;
        }

        if (requestParameters.spenderAddress !== undefined) {
            queryParameters['spenderAddress'] = requestParameters.spenderAddress;
        }

        if (requestParameters.ownerAddress !== undefined) {
            queryParameters['ownerAddress'] = requestParameters.ownerAddress;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        if (requestParameters.network !== undefined) {
            queryParameters['network'] = requestParameters.network;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/approval-state`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns data about if a token has been approved. **spenderAddress** for exchanging is the **allowanceTarget** value is returnded from the Exchange Price endpoint.
     * Token Approval State
     */
    async approvalControllerGetApprovalState(requestParameters: ApprovalControllerGetApprovalStateRequest): Promise<void> {
        await this.approvalControllerGetApprovalStateRaw(requestParameters);
    }

    /**
     * Returns data that can be used to build an ERC20 approval transaction for for a specific address. **spenderAddress** for exchanging is the **allowanceTarget** value is returnded from the Exchange Price endpoint.
     * Token Approval Transaction
     */
    async approvalControllerGetApprovalTransactionRaw(requestParameters: ApprovalControllerGetApprovalTransactionRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.tokenAddress === null || requestParameters.tokenAddress === undefined) {
            throw new runtime.RequiredError('tokenAddress','Required parameter requestParameters.tokenAddress was null or undefined when calling approvalControllerGetApprovalTransaction.');
        }

        if (requestParameters.spenderAddress === null || requestParameters.spenderAddress === undefined) {
            throw new runtime.RequiredError('spenderAddress','Required parameter requestParameters.spenderAddress was null or undefined when calling approvalControllerGetApprovalTransaction.');
        }

        if (requestParameters.ownerAddress === null || requestParameters.ownerAddress === undefined) {
            throw new runtime.RequiredError('ownerAddress','Required parameter requestParameters.ownerAddress was null or undefined when calling approvalControllerGetApprovalTransaction.');
        }

        if (requestParameters.gasPrice === null || requestParameters.gasPrice === undefined) {
            throw new runtime.RequiredError('gasPrice','Required parameter requestParameters.gasPrice was null or undefined when calling approvalControllerGetApprovalTransaction.');
        }

        const queryParameters: any = {};

        if (requestParameters.tokenAddress !== undefined) {
            queryParameters['tokenAddress'] = requestParameters.tokenAddress;
        }

        if (requestParameters.spenderAddress !== undefined) {
            queryParameters['spenderAddress'] = requestParameters.spenderAddress;
        }

        if (requestParameters.ownerAddress !== undefined) {
            queryParameters['ownerAddress'] = requestParameters.ownerAddress;
        }

        if (requestParameters.gasPrice !== undefined) {
            queryParameters['gasPrice'] = requestParameters.gasPrice;
        }

        if (requestParameters.amount !== undefined) {
            queryParameters['amount'] = requestParameters.amount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/approval-transaction`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns data that can be used to build an ERC20 approval transaction for for a specific address. **spenderAddress** for exchanging is the **allowanceTarget** value is returnded from the Exchange Price endpoint.
     * Token Approval Transaction
     */
    async approvalControllerGetApprovalTransaction(requestParameters: ApprovalControllerGetApprovalTransactionRequest): Promise<void> {
        await this.approvalControllerGetApprovalTransactionRaw(requestParameters);
    }

    /**
     * Returns data about the amount recieved if a trade would be made. **Should be called whenever a price needs to be calculated.**
     * Exchange Price
     */
    async exchangeControllerGetExchangePriceRaw(requestParameters: ExchangeControllerGetExchangePriceRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.sellTokenAddress === null || requestParameters.sellTokenAddress === undefined) {
            throw new runtime.RequiredError('sellTokenAddress','Required parameter requestParameters.sellTokenAddress was null or undefined when calling exchangeControllerGetExchangePrice.');
        }

        if (requestParameters.buyTokenAddress === null || requestParameters.buyTokenAddress === undefined) {
            throw new runtime.RequiredError('buyTokenAddress','Required parameter requestParameters.buyTokenAddress was null or undefined when calling exchangeControllerGetExchangePrice.');
        }

        if (requestParameters.sellAmount === null || requestParameters.sellAmount === undefined) {
            throw new runtime.RequiredError('sellAmount','Required parameter requestParameters.sellAmount was null or undefined when calling exchangeControllerGetExchangePrice.');
        }

        if (requestParameters.gasPrice === null || requestParameters.gasPrice === undefined) {
            throw new runtime.RequiredError('gasPrice','Required parameter requestParameters.gasPrice was null or undefined when calling exchangeControllerGetExchangePrice.');
        }

        const queryParameters: any = {};

        if (requestParameters.sellTokenAddress !== undefined) {
            queryParameters['sellTokenAddress'] = requestParameters.sellTokenAddress;
        }

        if (requestParameters.buyTokenAddress !== undefined) {
            queryParameters['buyTokenAddress'] = requestParameters.buyTokenAddress;
        }

        if (requestParameters.sellAmount !== undefined) {
            queryParameters['sellAmount'] = requestParameters.sellAmount;
        }

        if (requestParameters.gasPrice !== undefined) {
            queryParameters['gasPrice'] = requestParameters.gasPrice;
        }

        if (requestParameters.ownerAddress !== undefined) {
            queryParameters['ownerAddress'] = requestParameters.ownerAddress;
        }

        if (requestParameters.slippagePercentage !== undefined) {
            queryParameters['slippagePercentage'] = requestParameters.slippagePercentage;
        }

        if (requestParameters.network !== undefined) {
            queryParameters['network'] = requestParameters.network;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/exchange/price`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns data about the amount recieved if a trade would be made. **Should be called whenever a price needs to be calculated.**
     * Exchange Price
     */
    async exchangeControllerGetExchangePrice(requestParameters: ExchangeControllerGetExchangePriceRequest): Promise<void> {
        await this.exchangeControllerGetExchangePriceRaw(requestParameters);
    }

    /**
     * Returns both the relative price for a trade as well as the call data used to sumbit a transaction for a trade. **Should only be called when a trade is ready to be submitted.**
     * Exchange Quote
     */
    async exchangeControllerGetExchangeQuoteRaw(requestParameters: ExchangeControllerGetExchangeQuoteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.sellTokenAddress === null || requestParameters.sellTokenAddress === undefined) {
            throw new runtime.RequiredError('sellTokenAddress','Required parameter requestParameters.sellTokenAddress was null or undefined when calling exchangeControllerGetExchangeQuote.');
        }

        if (requestParameters.buyTokenAddress === null || requestParameters.buyTokenAddress === undefined) {
            throw new runtime.RequiredError('buyTokenAddress','Required parameter requestParameters.buyTokenAddress was null or undefined when calling exchangeControllerGetExchangeQuote.');
        }

        if (requestParameters.sellAmount === null || requestParameters.sellAmount === undefined) {
            throw new runtime.RequiredError('sellAmount','Required parameter requestParameters.sellAmount was null or undefined when calling exchangeControllerGetExchangeQuote.');
        }

        if (requestParameters.gasPrice === null || requestParameters.gasPrice === undefined) {
            throw new runtime.RequiredError('gasPrice','Required parameter requestParameters.gasPrice was null or undefined when calling exchangeControllerGetExchangeQuote.');
        }

        const queryParameters: any = {};

        if (requestParameters.sellTokenAddress !== undefined) {
            queryParameters['sellTokenAddress'] = requestParameters.sellTokenAddress;
        }

        if (requestParameters.buyTokenAddress !== undefined) {
            queryParameters['buyTokenAddress'] = requestParameters.buyTokenAddress;
        }

        if (requestParameters.sellAmount !== undefined) {
            queryParameters['sellAmount'] = requestParameters.sellAmount;
        }

        if (requestParameters.gasPrice !== undefined) {
            queryParameters['gasPrice'] = requestParameters.gasPrice;
        }

        if (requestParameters.ownerAddress !== undefined) {
            queryParameters['ownerAddress'] = requestParameters.ownerAddress;
        }

        if (requestParameters.slippagePercentage !== undefined) {
            queryParameters['slippagePercentage'] = requestParameters.slippagePercentage;
        }

        if (requestParameters.network !== undefined) {
            queryParameters['network'] = requestParameters.network;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/exchange/quote`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns both the relative price for a trade as well as the call data used to sumbit a transaction for a trade. **Should only be called when a trade is ready to be submitted.**
     * Exchange Quote
     */
    async exchangeControllerGetExchangeQuote(requestParameters: ExchangeControllerGetExchangeQuoteRequest): Promise<void> {
        await this.exchangeControllerGetExchangeQuoteRaw(requestParameters);
    }

    /**
     * Returns the exchanges supported by Zapper API.
     * Supported exchanges
     */
    async exchangeControllerGetSupportedExchangesRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/exchange/supported`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns the exchanges supported by Zapper API.
     * Supported exchanges
     */
    async exchangeControllerGetSupportedExchanges(): Promise<void> {
        await this.exchangeControllerGetSupportedExchangesRaw();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum ApprovalControllerGetApprovalStateNetworkEnum {
    Ethereum = 'ethereum',
    Polygon = 'polygon',
    Optimism = 'optimism',
    Xdai = 'xdai',
    BinanceSmartChain = 'binance-smart-chain',
    Fantom = 'fantom'
}
/**
    * @export
    * @enum {string}
    */
export enum ExchangeControllerGetExchangePriceNetworkEnum {
    Ethereum = 'ethereum',
    Polygon = 'polygon',
    Optimism = 'optimism',
    Xdai = 'xdai',
    BinanceSmartChain = 'binance-smart-chain',
    Fantom = 'fantom'
}
/**
    * @export
    * @enum {string}
    */
export enum ExchangeControllerGetExchangeQuoteNetworkEnum {
    Ethereum = 'ethereum',
    Polygon = 'polygon',
    Optimism = 'optimism',
    Xdai = 'xdai',
    BinanceSmartChain = 'binance-smart-chain',
    Fantom = 'fantom'
}
