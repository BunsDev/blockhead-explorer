/* tslint:disable */
/* eslint-disable */
/**
 * Zapper API
 * The Zapper API provides some of the most robust Defi related data, everything from liquidity and prices on different AMMs to complex Defi protocol balances all in one convenient place. In addition, the API also supports bridging between different networks as well as formatted Zap transaction endpoints. <br/><br/><br/> *Enter in our public API key in the Authorize section below to test the endpoints directly in swagger: **96e0cc51-a62e-42ca-acee-910ea7d2a241**
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Transaction,
    TransactionFromJSON,
    TransactionToJSON,
} from '../models';

export interface ZapInControllerGetZapInApprovalStateRequest {
    protocol: ZapInControllerGetZapInApprovalStateProtocolEnum;
    ownerAddress: string;
    sellTokenAddress: string;
    network?: ZapInControllerGetZapInApprovalStateNetworkEnum;
}

export interface ZapInControllerGetZapInApprovalTransactionRequest {
    protocol: ZapInControllerGetZapInApprovalTransactionProtocolEnum;
    ownerAddress: string;
    sellTokenAddress: string;
    gasPrice: string;
    network?: ZapInControllerGetZapInApprovalTransactionNetworkEnum;
}

export interface ZapInControllerGetZapInTransactionRequest {
    protocol: ZapInControllerGetZapInTransactionProtocolEnum;
    ownerAddress: string;
    sellAmount: string;
    sellTokenAddress: string;
    poolAddress: string;
    gasPrice: string;
    slippagePercentage: number;
    network?: ZapInControllerGetZapInTransactionNetworkEnum;
    affiliateAddress?: string;
    reserveTokenAddress?: string;
}

/**
 * 
 */
export class ZapInApi extends runtime.BaseAPI {

    /**
     * Provides a list of networks to protocols that are supported by the Zap In routes.
     * Supported Zap Ins
     */
    async zapInControllerGetSupportedZapInsRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/zap-in/supported`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Provides a list of networks to protocols that are supported by the Zap In routes.
     * Supported Zap Ins
     */
    async zapInControllerGetSupportedZapIns(): Promise<void> {
        await this.zapInControllerGetSupportedZapInsRaw();
    }

    /**
     * Retrieves an ERC20 approval status for a protocol zap-in
     * Zap In Approval State
     */
    async zapInControllerGetZapInApprovalStateRaw(requestParameters: ZapInControllerGetZapInApprovalStateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.protocol === null || requestParameters.protocol === undefined) {
            throw new runtime.RequiredError('protocol','Required parameter requestParameters.protocol was null or undefined when calling zapInControllerGetZapInApprovalState.');
        }

        if (requestParameters.ownerAddress === null || requestParameters.ownerAddress === undefined) {
            throw new runtime.RequiredError('ownerAddress','Required parameter requestParameters.ownerAddress was null or undefined when calling zapInControllerGetZapInApprovalState.');
        }

        if (requestParameters.sellTokenAddress === null || requestParameters.sellTokenAddress === undefined) {
            throw new runtime.RequiredError('sellTokenAddress','Required parameter requestParameters.sellTokenAddress was null or undefined when calling zapInControllerGetZapInApprovalState.');
        }

        const queryParameters: any = {};

        if (requestParameters.ownerAddress !== undefined) {
            queryParameters['ownerAddress'] = requestParameters.ownerAddress;
        }

        if (requestParameters.sellTokenAddress !== undefined) {
            queryParameters['sellTokenAddress'] = requestParameters.sellTokenAddress;
        }

        if (requestParameters.network !== undefined) {
            queryParameters['network'] = requestParameters.network;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/zap-in/{protocol}/approval-state`.replace(`{${"protocol"}}`, encodeURIComponent(String(requestParameters.protocol))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves an ERC20 approval status for a protocol zap-in
     * Zap In Approval State
     */
    async zapInControllerGetZapInApprovalState(requestParameters: ZapInControllerGetZapInApprovalStateRequest): Promise<void> {
        await this.zapInControllerGetZapInApprovalStateRaw(requestParameters);
    }

    /**
     * Builds an ERC20 approval transaction for a protocol zap-in
     * Zap In Approval Transaction
     */
    async zapInControllerGetZapInApprovalTransactionRaw(requestParameters: ZapInControllerGetZapInApprovalTransactionRequest): Promise<runtime.ApiResponse<Transaction>> {
        if (requestParameters.protocol === null || requestParameters.protocol === undefined) {
            throw new runtime.RequiredError('protocol','Required parameter requestParameters.protocol was null or undefined when calling zapInControllerGetZapInApprovalTransaction.');
        }

        if (requestParameters.ownerAddress === null || requestParameters.ownerAddress === undefined) {
            throw new runtime.RequiredError('ownerAddress','Required parameter requestParameters.ownerAddress was null or undefined when calling zapInControllerGetZapInApprovalTransaction.');
        }

        if (requestParameters.sellTokenAddress === null || requestParameters.sellTokenAddress === undefined) {
            throw new runtime.RequiredError('sellTokenAddress','Required parameter requestParameters.sellTokenAddress was null or undefined when calling zapInControllerGetZapInApprovalTransaction.');
        }

        if (requestParameters.gasPrice === null || requestParameters.gasPrice === undefined) {
            throw new runtime.RequiredError('gasPrice','Required parameter requestParameters.gasPrice was null or undefined when calling zapInControllerGetZapInApprovalTransaction.');
        }

        const queryParameters: any = {};

        if (requestParameters.ownerAddress !== undefined) {
            queryParameters['ownerAddress'] = requestParameters.ownerAddress;
        }

        if (requestParameters.sellTokenAddress !== undefined) {
            queryParameters['sellTokenAddress'] = requestParameters.sellTokenAddress;
        }

        if (requestParameters.gasPrice !== undefined) {
            queryParameters['gasPrice'] = requestParameters.gasPrice;
        }

        if (requestParameters.network !== undefined) {
            queryParameters['network'] = requestParameters.network;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/zap-in/{protocol}/approval-transaction`.replace(`{${"protocol"}}`, encodeURIComponent(String(requestParameters.protocol))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionFromJSON(jsonValue));
    }

    /**
     * Builds an ERC20 approval transaction for a protocol zap-in
     * Zap In Approval Transaction
     */
    async zapInControllerGetZapInApprovalTransaction(requestParameters: ZapInControllerGetZapInApprovalTransactionRequest): Promise<Transaction> {
        const response = await this.zapInControllerGetZapInApprovalTransactionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Builds a zap-in transaction for usage with Web3, complete with best swap from 0x.
     * Zap In Transaction
     */
    async zapInControllerGetZapInTransactionRaw(requestParameters: ZapInControllerGetZapInTransactionRequest): Promise<runtime.ApiResponse<Transaction>> {
        if (requestParameters.protocol === null || requestParameters.protocol === undefined) {
            throw new runtime.RequiredError('protocol','Required parameter requestParameters.protocol was null or undefined when calling zapInControllerGetZapInTransaction.');
        }

        if (requestParameters.ownerAddress === null || requestParameters.ownerAddress === undefined) {
            throw new runtime.RequiredError('ownerAddress','Required parameter requestParameters.ownerAddress was null or undefined when calling zapInControllerGetZapInTransaction.');
        }

        if (requestParameters.sellAmount === null || requestParameters.sellAmount === undefined) {
            throw new runtime.RequiredError('sellAmount','Required parameter requestParameters.sellAmount was null or undefined when calling zapInControllerGetZapInTransaction.');
        }

        if (requestParameters.sellTokenAddress === null || requestParameters.sellTokenAddress === undefined) {
            throw new runtime.RequiredError('sellTokenAddress','Required parameter requestParameters.sellTokenAddress was null or undefined when calling zapInControllerGetZapInTransaction.');
        }

        if (requestParameters.poolAddress === null || requestParameters.poolAddress === undefined) {
            throw new runtime.RequiredError('poolAddress','Required parameter requestParameters.poolAddress was null or undefined when calling zapInControllerGetZapInTransaction.');
        }

        if (requestParameters.gasPrice === null || requestParameters.gasPrice === undefined) {
            throw new runtime.RequiredError('gasPrice','Required parameter requestParameters.gasPrice was null or undefined when calling zapInControllerGetZapInTransaction.');
        }

        if (requestParameters.slippagePercentage === null || requestParameters.slippagePercentage === undefined) {
            throw new runtime.RequiredError('slippagePercentage','Required parameter requestParameters.slippagePercentage was null or undefined when calling zapInControllerGetZapInTransaction.');
        }

        const queryParameters: any = {};

        if (requestParameters.ownerAddress !== undefined) {
            queryParameters['ownerAddress'] = requestParameters.ownerAddress;
        }

        if (requestParameters.sellAmount !== undefined) {
            queryParameters['sellAmount'] = requestParameters.sellAmount;
        }

        if (requestParameters.sellTokenAddress !== undefined) {
            queryParameters['sellTokenAddress'] = requestParameters.sellTokenAddress;
        }

        if (requestParameters.poolAddress !== undefined) {
            queryParameters['poolAddress'] = requestParameters.poolAddress;
        }

        if (requestParameters.gasPrice !== undefined) {
            queryParameters['gasPrice'] = requestParameters.gasPrice;
        }

        if (requestParameters.slippagePercentage !== undefined) {
            queryParameters['slippagePercentage'] = requestParameters.slippagePercentage;
        }

        if (requestParameters.network !== undefined) {
            queryParameters['network'] = requestParameters.network;
        }

        if (requestParameters.affiliateAddress !== undefined) {
            queryParameters['affiliateAddress'] = requestParameters.affiliateAddress;
        }

        if (requestParameters.reserveTokenAddress !== undefined) {
            queryParameters['reserveTokenAddress'] = requestParameters.reserveTokenAddress;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/v1/zap-in/{protocol}/transaction`.replace(`{${"protocol"}}`, encodeURIComponent(String(requestParameters.protocol))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionFromJSON(jsonValue));
    }

    /**
     * Builds a zap-in transaction for usage with Web3, complete with best swap from 0x.
     * Zap In Transaction
     */
    async zapInControllerGetZapInTransaction(requestParameters: ZapInControllerGetZapInTransactionRequest): Promise<Transaction> {
        const response = await this.zapInControllerGetZapInTransactionRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum ZapInControllerGetZapInApprovalStateProtocolEnum {
    Balancer = 'balancer',
    Bancor = 'bancor',
    Curve = 'curve',
    _1inch = '1inch',
    Pancakeswap = 'pancakeswap',
    Pooltogether = 'pooltogether',
    Sushiswap = 'sushiswap',
    UniswapV2 = 'uniswap-v2',
    Yearn = 'yearn',
    Pickle = 'pickle',
    Harvest = 'harvest'
}
/**
    * @export
    * @enum {string}
    */
export enum ZapInControllerGetZapInApprovalStateNetworkEnum {
    Ethereum = 'ethereum',
    Polygon = 'polygon',
    Optimism = 'optimism',
    Xdai = 'xdai',
    BinanceSmartChain = 'binance-smart-chain',
    Fantom = 'fantom'
}
/**
    * @export
    * @enum {string}
    */
export enum ZapInControllerGetZapInApprovalTransactionProtocolEnum {
    Balancer = 'balancer',
    Bancor = 'bancor',
    Curve = 'curve',
    _1inch = '1inch',
    Pancakeswap = 'pancakeswap',
    Pooltogether = 'pooltogether',
    Sushiswap = 'sushiswap',
    UniswapV2 = 'uniswap-v2',
    Yearn = 'yearn',
    Pickle = 'pickle',
    Harvest = 'harvest'
}
/**
    * @export
    * @enum {string}
    */
export enum ZapInControllerGetZapInApprovalTransactionNetworkEnum {
    Ethereum = 'ethereum',
    Polygon = 'polygon',
    Optimism = 'optimism',
    Xdai = 'xdai',
    BinanceSmartChain = 'binance-smart-chain',
    Fantom = 'fantom'
}
/**
    * @export
    * @enum {string}
    */
export enum ZapInControllerGetZapInTransactionProtocolEnum {
    Balancer = 'balancer',
    Bancor = 'bancor',
    Curve = 'curve',
    _1inch = '1inch',
    Pancakeswap = 'pancakeswap',
    Pooltogether = 'pooltogether',
    Sushiswap = 'sushiswap',
    UniswapV2 = 'uniswap-v2',
    Yearn = 'yearn',
    Pickle = 'pickle',
    Harvest = 'harvest'
}
/**
    * @export
    * @enum {string}
    */
export enum ZapInControllerGetZapInTransactionNetworkEnum {
    Ethereum = 'ethereum',
    Polygon = 'polygon',
    Optimism = 'optimism',
    Xdai = 'xdai',
    BinanceSmartChain = 'binance-smart-chain',
    Fantom = 'fantom'
}
